![example workflow](https://github.com/buschwaker/wargaming/actions/workflows/main.yml/badge.svg)

# Тестовое задание на позицию стажера (Python Development)


### Особенности проекта
<p>Перед написанием основного кода были написаны тесты. Использовалась методология TDD. На этапе разработки простые фрагменты кода контролировались с помощью `doctest`.</p>

Запуск юниттестов, линтера, а также статический анализ кода происходит каждый раз при пуше с помощью инструкций, описанных в [main.yml](https://github.com/buschwaker/wargaming/blob/main/.github/workflows/main.yml).

### Алгоритм определения четности числа
Посмотреть каждый из описанных алгоритмов, их плюсы и минусы можно [здесь](https://github.com/buschwaker/wargaming/blob/main/tasks/task1.py). <br>Для каждого из алгоритмов написаны тестовые сценарии `doctest`
### Циклический буфер FIFO
Посмотреть каждый из описанных алгоритмов, их плюсы и минусы можно [здесь](https://github.com/buschwaker/wargaming/blob/main/tasks/task2.py). <br>Для каждого из алгоритмов написаны тестовые сценарии `doctest`
### Оптимальный алгоритм сортировки

<p>Основное отличие сортировки Тони Хоара(быстрой) от сортировки слиянием заключается в том, что первая требует меньшего пространства памяти, работает эффективно с короткими массивами величин, однако в некоторых случаях время выполнения будет квадратичным.</p>

Так в случае с быстрым алгоритмом, реализованным в [данном примере](https://github.com/buschwaker/wargaming/blob/main/tasks/task3.py) за опорный элемент `pivot` берется первый элемент последовательности. И при попытке отсортировать уже отсортированную коллекцию, список `less` будет всегда пустым. Так `pivot` будет взят N раз и на каждой итерации сравнен с оставшимися элементами последовательности. Это и есть худший случай, при котором сложность алгоритма быстрой сортировки будет квадратичной.

<p>В таблицах ниже представлены результаты измерения скоростей сортировок (быстрая и слиянием) списков случайных величин и отсортированных по убыванию/возрастанию.</p>

<p>Из результатов измерений можно сделать вывод, что по процессорным тикам скорость сортировки быстрым алгоритмом выше, чем слиянием. Однако быстрая сортировка дольше работает с уже отсортированными списками.</p>
<table>
    <caption>Список случайных величин</caption>
    <thead>
        <tr>
            <th></th>
            <th>Минимальное время, мс</th>
            <th>Максимальное время, мс</th>
            <th>Медианное время, мс</th>
            <th>Среднее (ариф.) время, мс</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>слиянием</th>
            <td>0.25</td>
            <td>0.65</td>
            <td>0.26</td>
            <td>0.29</td>
        </tr>
        <tr>
            <th>быстрая</th>
            <td>0.09</td>
            <td>0.31</td>
            <td>0.09</td>
            <td>0.1</td>
        </tr>
    </tbody>
</table>

<table>
    <caption>Отсортированный список</caption>
    <thead>
        <tr>
            <th></th>
            <th>Минимальное время, мс</th>
            <th>Максимальное время, мс</th>
            <th>Медианное время, мс</th>
            <th>Среднее (ариф.) время, мс</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>слиянием</th>
            <td>0.19</td>
            <td>0.45</td>
            <td>0.21</td>
            <td>0.23</td>
        </tr>
        <tr>
            <th>быстрая</th>
            <td>0.6</td>
            <td>1.32</td>
            <td>0.62</td>
            <td>0.67</td>
        </tr>
    </tbody>
</table>

<table>
    <caption>Отсортированный от большего к меньшему список</caption>
    <thead>
        <tr>
            <th></th>
            <th>Минимальное время, мс</th>
            <th>Максимальное время, мс</th>
            <th>Медианное время, мс</th>
            <th>Среднее (ариф.) время, мс</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>слиянием</th>
            <td>0.2</td>
            <td>0.53</td>
            <td>0.21</td>
            <td>0.22</td>
        </tr>
        <tr>
            <th>быстрая</th>
            <td>0.46</td>
            <td>1.79</td>
            <td>0.47</td>
            <td>0.52</td>
        </tr>
    </tbody>
</table>

### Инструкция по запуску проекта на своей машине:
1. Скачиваем репозиторий
2. Устанавливаем и активируем виртуальное окружение  
3. Устанавливаем зависимости `pip install -r requirements.txt`